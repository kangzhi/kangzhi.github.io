<!DOCTYPE html>


<script type="text/javascript" color="253,253,253" opacity="0.5" zindex="-2" count="150" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>




  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="OpenGL,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="这里是分割线">
<meta name="keywords" content="OpenGL">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenGL Rendering Pipeline">
<meta property="og:url" content="http://kangzhi.github.io/2019/01/11/OpenGL-Rendering-Pipeline/index.html">
<meta property="og:site_name" content="KinGil&#39;s Blog">
<meta property="og:description" content="这里是分割线">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://i2.bvimg.com/673749/e8feb2f4a6b54add.png">
<meta property="og:image" content="http://i2.bvimg.com/673749/c94e1becdc0f86ae.png">
<meta property="og:image" content="http://i2.bvimg.com/673749/fa8d53aff2bd954c.png">
<meta property="og:image" content="http://i2.bvimg.com/673749/a9dc41513d61b5aa.png">
<meta property="og:image" content="http://i2.bvimg.com/673749/384fa28ecb053c35.png">
<meta property="og:image" content="http://i2.bvimg.com/673749/41990eb35ecd47dd.png">
<meta property="og:updated_time" content="2019-02-18T02:52:16.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OpenGL Rendering Pipeline">
<meta name="twitter:description" content="这里是分割线">
<meta name="twitter:image" content="http://i2.bvimg.com/673749/e8feb2f4a6b54add.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://kangzhi.github.io/2019/01/11/OpenGL-Rendering-Pipeline/">





  <title>OpenGL Rendering Pipeline | KinGil's Blog</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">KinGil's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">April is coming</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://kangzhi.github.io/2019/01/11/OpenGL-Rendering-Pipeline/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KinGil">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KinGil's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">OpenGL Rendering Pipeline</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-11T21:32:32+08:00">
                2019-01-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/" itemprop="url" rel="index">
                    <span itemprop="name">OpenGL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>这里是分割线<br><a id="more"></a></p>
<h1 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h1><h2 id="固定管线和可编程管线"><a href="#固定管线和可编程管线" class="headerlink" title="固定管线和可编程管线"></a>固定管线和可编程管线</h2><p>core-profile immediate mode，教程都针对core-profile进行。这些对应的是3.3及其以后的版本，相比固定管线来说效率更高。固定管线学习起来比较容易封装的好，但是渲染效率低。core-profile的话学习起来稍微困难点，需要真的理解相关机制和原理才可以。<br>现在许多高版本的opengl都支持很多新的特定，这些实现必须要更新显卡相关的驱动。但是一般情况下核心的函数基本都是能用的。<br>扩展是OpenGL的一大特色，提供使用思路：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(GL_ARB_extension_name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Do cool new and modern stuff supported by hardware</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Extension not supported: do it the old way</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p>context说白了就是状态机的内容。在OpenGL我们通过设定选项，操控buffers来改变状态机，然后使用当下的context进行渲染。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>一个对象就是opengl里面状态的子集的集合。比如我们可以有一个对象表示绘制窗口的设置。然后我们可以设置它的大小，支持多少颜色等。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">object_name</span> &#123;</span></span><br><span class="line">    <span class="keyword">float</span>  option1;</span><br><span class="line">    <span class="keyword">int</span>    option2;</span><br><span class="line">    <span class="keyword">char</span>[] name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// The State of OpenGL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OpenGL_Context</span> &#123;</span></span><br><span class="line">  	object* object_Window_Target;	</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// create object</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> objectId = <span class="number">0</span>;</span><br><span class="line">glGenObject(<span class="number">1</span>, &amp;objectId);</span><br><span class="line"><span class="comment">// bind object to context</span></span><br><span class="line">glBindObject(GL_WINDOW_TARGET, objectId);</span><br><span class="line"><span class="comment">// set options of object currently bound to GL_WINDOW_TARGET</span></span><br><span class="line">glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, <span class="number">800</span>);</span><br><span class="line">glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, <span class="number">600</span>);</span><br><span class="line"><span class="comment">// set context target back to default</span></span><br><span class="line">glBindObject(GL_WINDOW_TARGET, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//以上不是连续代码，而且只是一个过程的抽象</span></span><br></pre></td></tr></table></figure></p>
<p> There are objects for example that act as container objects for 3D model data (a house or a character) and whenever we want to draw one of them, we bind the object containing the model data that we want to draw (we first created and set options for these objects). Having several objects allows us to specify many models and whenever we want to draw a specific model, we simply bind the corresponding object before drawing without setting all their options again.</p>
<h2 id="hellowindow的一些流程解释"><a href="#hellowindow的一些流程解释" class="headerlink" title="hellowindow的一些流程解释"></a>hellowindow的一些流程解释</h2><p>创建窗口-定义context，然后处理输入输出。</p>
<h3 id="固定管线"><a href="#固定管线" class="headerlink" title="固定管线"></a>固定管线</h3><p>具体的代码在上一篇文章中已经给出了，都是基于glut的最基本的实现，比较简单，属于固定管线编程。基于固定管线我上手了一些例子，当时学习的时候进行过一些简单的绘制，比如立方体啊什么的。但是因为最后项目需要要用到shader，所以那块的进度也就基本到那个进度。当时给同事做了一个个基于硬件交互来进行动态绘制的demo。可惜并没有保存视频，大致就是基于视觉追踪进行用交互笔抓去一个立方体的实现，基本实现了整个AR的流程（识别，矩阵变换，现实渲染，虚拟内容渲染和shader融合等），以后会把当初的思路通过专题记录下来。</p>
<h3 id="可编程管线"><a href="#可编程管线" class="headerlink" title="可编程管线"></a>可编程管线</h3><p>在这没什么好讲的，因为只是绘制一个窗口的话没用到具体内容，说下大致的流程：（使用glfw）<br>1 glfw初始化和相关配置，注意平台相关；<br>2 glfw创建窗口，包括创建窗口重绘回调；<br>3 glad加载所有的opengl函数指针；<br>4 渲染循环 input处理-渲染-交换缓冲区和poll IO events；<br>5 glfw结束，清除glfw资源；<br>相关完整代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span>;</span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// glfw: initialize and configure</span></span><br><span class="line">    <span class="comment">// ------------------------------</span></span><br><span class="line">    glfwInit();</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); <span class="comment">// uncomment this statement to fix compilation on OS X</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// glfw window creation</span></span><br><span class="line">    <span class="comment">// --------------------</span></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, <span class="string">"LearnOpenGL"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to create GLFW window"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line">    <span class="comment">// glad: load all OpenGL function pointers</span></span><br><span class="line">    <span class="comment">// ---------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to initialize GLAD"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// render loop</span></span><br><span class="line">    <span class="comment">// -----------</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="comment">// -----</span></span><br><span class="line">        processInput(window);</span><br><span class="line">        <span class="comment">// render</span></span><br><span class="line">        <span class="comment">// ------</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">        <span class="comment">// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span></span><br><span class="line">        <span class="comment">// -------------------------------------------------------------------------------</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// glfw: terminate, clearing all previously allocated GLFW resources.</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// glfw: whenever the window size changed (by OS or user resize) this callback function executes</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// make sure the viewport matches the new window dimensions; note that width and </span></span><br><span class="line">    <span class="comment">// height will be significantly larger than specified on retina displays.</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="绘制一个三角形"><a href="#绘制一个三角形" class="headerlink" title="绘制一个三角形"></a>绘制一个三角形</h1><p>你的绘制永远是3D内容，但是opengl需要将3d空间变换为2D空间，这部分是由OpenGL的<font color="green">Graphic Pipeline</font>完成的。这个管线可以分成两个大的阶段：第一部分将3d坐标转换成2d坐标，第二部分是将2d坐标转换成实际的颜色像素。该部分我们着重讨论这个流程。这个流程是高度specialized的（有一个专门的函数）而且很容易能够并行处理。相应，显卡里有巨多的小单元来处理这个过程，在管线的每一步都在它上面跑一个小程序，这就是shader。下图是可编程管线的流程，蓝色部分是可以自定义的。<br>见图opengl2-001<br><img src="http://i2.bvimg.com/673749/e8feb2f4a6b54add.png" alt="Markdown"><br>顶点数据：顶点shader-形状组装-几何shader-光栅化-片元shader-测试和渲染<br>作为输入，我们提供了一组可以组成三角形的3d坐标，叫做Vertex Data。这个vertexdata是一些顶点的集合。一个顶点就是每一个3d坐标的数据集合。这个数据集合可能被包含了任何可能的数据，这些东西用vertex attributes表示。<br>你告诉opengl你渲染的是什么类型的数据集，我们需要规定<font color="green">primitives</font>（就是预定义好的渲染类型），包括<font color="blue">GL_POINTS, GL_TRIANGLES and GL_LINE_STRIP</font>等。<br>1 vertex shader<br>进行3d坐标转换，目的是我们可以基于顶点属性做一些基本的处理。<br>齐次坐标变换等。<br>2 primitive assembly<br>将所有顶点作为输入，基于给定的形状组织所有的顶点，比如一个三角形<br>3 几何shader<br>他会基于给定的形状增加一些新的顶点，比如我们要生成一个三角形，知道三个点，几何shader会根据预置类型-三角形，自动填补三角形三条边上的点。<br>4 光栅化<br>将上一步的结果转化成相应的屏幕上的像素，分割成可以被frgament shader处理的片元。同时进行裁剪，它会把所有位于视野外/屏幕外的片元裁剪掉，提高性能。<br>片元就是opengl来进行渲染要一个单独像素所需要的所有数据。<br>5 片元shader最主要的目的是计算像素的最终颜色，这是所有opengl高级特性发生的阶段。包含可以进行这些处理的数据：光照、阴影、光的颜色等<br>6 深度测试和渲染<br>所有的像素点颜色计算完成后，进行遮挡、半透明等的处理。<br>我们核心要关注的就是顶点shader和片元shader。</p>
<h2 id="顶点输入"><a href="#顶点输入" class="headerlink" title="顶点输入"></a>顶点输入</h2><p>opengl最后渲染的的是一个在单位正方体内的<font color="green">齐次(normalized device ccordinate)</font>坐标，xyz都从-1到1。<br>现在我们要渲染一个三角形，直接定义到NDC坐标：<br>float vertices[] = {<br>    -0.5f, -0.5f, 0.0f,<br>​     0.5f, -0.5f, 0.0f,<br>​     0.0f,  0.5f, 0.0f<br>};<br>图002<img src="http://i2.bvimg.com/673749/c94e1becdc0f86ae.png" alt="Markdown"></p>
<p>顶点数据在被vertex shader处理后，肯定是在NDC空间内的坐标。其他的不被渲染。<br>接着，这些齐次坐标系内的坐标，会通过你配置的<font color="red">glViewport</font>转换到屏幕坐标<font color="red">screen-space coordinate</font>。这些屏幕坐标转换成片元就是片元shader的输入数据。</p>
<p>顶点数据准备好以后，我们把他们提供给vertex shader，通过在GPU上创建显存区域，在这部分区域存储vertex data。具体通过<font color="red">vertex buffet object(VBO)</font>实现。他能够存储大量的顶点数据，所以我们要尽可能地将这些数据一次发送给GPU，剩下的GPU处理起来就很快了。VBO是一个对象，我们在OpenGL里都有一个唯一的ID指向这个buffer对象：<br><strong>unsigned int VBO;</strong><br><strong>glGenBuffers(1, &amp;VBO);</strong><br>OpenGL有很多不同种类的buffer对象，顶点的buffer对象叫<font color="red">GL_ARRAY_BUFFER</font>，OpenGL容许我们一次绑定到不同的buffers，只要他们有不同的buffer类型。我们使用<font color="red">glBindBuffer</font>将新创建的buffer绑定给GL_ARRAY_BUFFER对象：<br><strong>glBindBuffer(GL_ARRAY_BUFFER, VBO);</strong><br>绑定以后，针对GL_ARRAY_BUFFER对象的任何调用都被用来配置当前的VBO。使用<font color="red">glBufferData</font>将定义好的顶点数据传给buffer的memory：<br><strong>glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</strong></p>
<p>glBufferData解释说明：<br>glBufferData is a function specifically targeted to copy user-defined data into the currently bound buffer. Its first argument is the type of the buffer we want to copy data into: the vertex buffer object currently bound to the GL_ARRAY_BUFFER target. The second argument specifies the size of the data (in bytes) we want to pass to the buffer; a simple sizeof of the vertex data suffices. The third parameter is the actual data we want to send.<br>The fourth parameter specifies how we want the graphics card to manage the given data. This can take 3 forms:<br>GL_STATIC_DRAW: the data will most likely not change at all or very rarely.<br>GL_DYNAMIC_DRAW: the data is likely to change a lot.<br>GL_STREAM_DRAW: the data will change every time it is drawn.</p>
<p>The position data of the triangle does not change and stays the same for every render call so its usage type should best be GL_STATIC_DRAW. If, for instance, one would have a buffer with data that is likely to change frequently, a usage type of GL_DYNAMIC_DRAW or GL_STREAM_DRAW ensures the graphics card will place the data in memory that allows for faster writes.</p>
<p>我们已经通过VBO将定点数据存储到显卡的内存中，下一步就是创建vertex shader 和fragment shader来处理这些数据。</p>
<h2 id="vertex-shader"><a href="#vertex-shader" class="headerlink" title="vertex shader"></a>vertex shader</h2><p>现代OpenGL中，我们至少需要一个vertex shader和一个fragment shader。这里简单讨论和配置两个shader 的实现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;gl_Position = vec4(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用GLSL语言，通过in关键字声明输入的顶点数据。我们现在只关注位置数据，所以我们是需要一个顶点属性。GLSL有一个向量类型包含1-4个浮点数据。同时，通过layout (location = 0)我们也设置了输入数据的位置。注意xyzw中w是用来处理<font color="green">perspective division</font>的。<br>参考阅读：<a href="https://stackoverflow.com/questions/17269686/why-do-we-need-perspective-division" target="_blank" rel="noopener">https://stackoverflow.com/questions/17269686/why-do-we-need-perspective-division</a><br>为了设置certex shader的输出我们必须将位置数据赋值给预置的<font color="blue">gl_position</font>蓝色参数，在后台是一个vec4类型。在main函数的最后，gl_position都是vertex shader 的输出，不管我们怎么设置的。因为我们的输入是三维的向量所以转化成四维。<br>当前的shader只是一个特别简单的，没有做任何处理，也没有做到NDC的坐标变化-通常来讲这一步是必须的。</p>
<h2 id="编译shader"><a href="#编译shader" class="headerlink" title="编译shader"></a>编译shader</h2><p>1create a sahder object：<br><strong>unsigned int vertexShader;</strong><br><strong>vertexShader = glCreateShader(GL_VERTEX_SHADER);</strong><br>2attach the shader source code to the shader object and compile<br><strong>glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);</strong><br><strong>glCompileShader(vertexShader);</strong></p>
<h2 id="片元shader"><a href="#片元shader" class="headerlink" title="片元shader"></a>片元shader</h2><p>这一步计算最终像素的颜色，这里只输出特定的颜色。<br>计算机系统中颜色是四维的向量，rgba，每一个范围在0.0和1.0之间。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; FragColor = vec4(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.2f</span>, <span class="number">1.0f</span>);&#125;</span><br></pre></td></tr></table></figure></p>
<p>fragment仅仅需要一个输出参数，是一个定义最终颜色的四维的向量，我们需要自己构建。利用关键字out，我们定义了<font color="blue">FragColor</font>。编译类似：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader;</span><br><span class="line">fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">glCompileShader(fragmentShader);</span><br></pre></td></tr></table></figure></p>
<p>最后一步，将shader对象链接进shader program绿色用来渲染。</p>
<h2 id="sahder-program"><a href="#sahder-program" class="headerlink" title="sahder program"></a>sahder program</h2><p>将编译好的shader<font color="green">link</font>到shder program对象，然后在渲染前激活这个shader。</p>
<ol>
<li>创建shaderprogram 对象by glcreateprogram：<br><strong>unsigned int shaderProgram;</strong><br><strong>shaderProgram = glCreateProgram();</strong></li>
<li>用gllinkprogram连接：<br><strong>glAttachShader(shaderProgram, vertexShader);</strong><br><strong>glAttachShader(shaderProgram, fragmentShader);</strong><br><strong>glLinkProgram(shaderProgram);</strong></li>
<li>连接最终得到的是一个program对象，使用：<br><strong>glUseProgram(shaderProgram);</strong></li>
<li>删除shader 对象，连接后shader program就不用了。<br><strong>glDeleteShader(vertexShader);</strong><br><strong>glDeleteShader(fragmentShader);</strong><br>综上，我们将输入数据给了GPU，也通过两个shader告诉GPU应该如何处理这些数据。但是opengl依然不知道如何如何解释顶点中的数据、如何链接顶点数据和vertexshader中的属性。我们告诉他。<h2 id="连接顶点属性"><a href="#连接顶点属性" class="headerlink" title="连接顶点属性"></a>连接顶点属性</h2>vertex容许我们以vertex attributes的形式规定任何的输入，比较灵活，也需要更多的人工处理。我们需要在渲染前告诉opengl如何解释这些数据。<br>我们的vertex buffer data 结构现在这样：</li>
<li>The position data is stored as 32-bit (4 byte) floating point values.</li>
<li>Each position is composed of 3 of those values.</li>
<li>There is no space (or other values) between each set of 3 values. The values are tightly packed in the array.</li>
<li>The first value in the data is at the beginning of the buffer.<br>图003<br><img src="http://i2.bvimg.com/673749/fa8d53aff2bd954c.png" alt="Markdown"><br>所以我们用以下函数告诉OpenGL该怎么理解：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>1 定义了我们匹配哪个vertex 属性，跟location = 0对应<br>2 规定了vertex 属性的长度，我们现在是vec3，所以是3<br>3 数据类型<br>4 规定了我们是不是需要将数据齐次化<br>5 下一个数据出现的距离间隔，默认0的话就是连续的数据空间（stride）<br>6 where psition data begins in the buffer（offset）</p>
<p>总结来说就是以下两点：<br>1 每一个vertex 属性从VBO管理的显存中拿取它的数据；<br>2 从那个VBO中拿数据呢（可能有很多个VBO），取决于当前绑定给LG_ARRAY_BUFFER的VBO，这个过程发生在调用<font color="red">glVertexAttribPointer</font>的时候。</p>
<p>然后，通过<font color="red">glEnableVertexAttribArray</font>，我们使能vertex attributes，将vertex attributes location（也就是0）当作它的参数。因为默认vertex attributes是关闭的。接下来整个绘制流程就可以这样展开：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0. copy our vertices array in a buffer for OpenGL to use</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 1. then set the vertex attributes pointers</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);  </span><br><span class="line"><span class="comment">// 2. use our shader program when we want to render an object</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line"><span class="comment">// 3. now draw the object </span></span><br><span class="line">someOpenGLFunctionThatDrawsOurTriangle();</span><br></pre></td></tr></table></figure></p>
<p>最后考虑这个问题，如果有5个vertex attributes，100多个不同的物体，绑定buffer object和为每个物体配置verex attributes将很繁杂。</p>
<h2 id="Vertex-Array-Object"><a href="#Vertex-Array-Object" class="headerlink" title="Vertex Array Object"></a>Vertex Array Object</h2><p>wiki：<a href="https://www.khronos.org/opengl/wiki/Vertex_Specification#Vertex_Array_Object" target="_blank" rel="noopener">https://www.khronos.org/opengl/wiki/Vertex_Specification#Vertex_Array_Object</a><br>主要目的是解决在不同的vertex data和attribute config切换时，只需要切换绑定的VAO即可。根据wiki的解释这个VAO里存放了提供顶点数据时所需要的状态数据。<br>准确来说，VAO对象存储了以下的信息：<br>1 <font color="red">glEnableVertexAttribArray</font>或者<font color="red">glDisableVertexAttribArray</font>的调用<br>2 通过 <font color="red">glVertexAttribPointer</font>的vertex attributes 配置<br>3 通过<font color="red">glVertexAttribPointer</font>的调用，找到与vertex attributes关联的VBO<br>图004<br><img src="http://i2.bvimg.com/673749/a9dc41513d61b5aa.png" alt="Markdown"><br>创建和绑定VAO：<br><strong>unsigned int VAO;</strong><br><strong>glGenVertexArrays(1, &amp;VAO);</strong><br>要使用VAO你必须使用<font color="red">glBindVertexArray</font>绑定VAO。从这点上来讲，我们应该绑定或者配置相应的VBOS和属性pointers ,然后再将VAO解绑以便后续需要。一旦我们需要画一个图形，我们只需要将绑定VAOwith首选的设置：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ..:: Initialization code (done once (unless your object frequently changes)) :: ..</span></span><br><span class="line"><span class="comment">// 1. bind Vertex Array Object</span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line"><span class="comment">// 2. copy our vertices array in a buffer for OpenGL to use</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 3. then set our vertex attributes pointers</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);  </span><br><span class="line"><span class="comment">// ..:: Drawing code (in render loop) :: ..</span></span><br><span class="line"><span class="comment">// 4. draw the object</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">someOpenGLFunctionThatDrawsOurTriangle();</span><br></pre></td></tr></table></figure></p>
<p>以上就是所有的流程。一个VAO保存我们vertex atttributes配置数据和用哪个VBO。通常你需要绘制不同的对象时，首先生成/配置所有的VAOs（thus VBO和attributes pointers）并且保存以便后面需要。我们需要绘制我们的对象时，我们拿取相应的VAO，绑定它，然后再解绑。</p>
<h2 id="绘制三角形"><a href="#绘制三角形" class="headerlink" title="绘制三角形"></a>绘制三角形</h2><p>调用<font color="red">glDrawArrays</font>绘制，使用：当前激活的shader，之前定义的vertex attributes 配置以及VBO的顶点数据（通过VAO简介绑定的）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// glfw window creation</span></span><br><span class="line">    <span class="comment">// --------------------</span></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, <span class="string">"LearnOpenGL"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line">    <span class="comment">// glad: load all OpenGL function pointers</span></span><br><span class="line">    <span class="comment">// ---------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to initialize GLAD"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// build and compile our shader program</span></span><br><span class="line">    <span class="comment">// ------------------------------------</span></span><br><span class="line">    <span class="comment">// vertex shader</span></span><br><span class="line">    <span class="keyword">int</span> vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">    glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(vertexShader);</span><br><span class="line">    <span class="comment">// fragment shader</span></span><br><span class="line">    <span class="keyword">int</span> fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">    glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(fragmentShader);</span><br><span class="line">    <span class="comment">// link shaders</span></span><br><span class="line">    <span class="keyword">int</span> shaderProgram = glCreateProgram();</span><br><span class="line">    glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">    glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">    glLinkProgram(shaderProgram);</span><br><span class="line">    glDeleteShader(vertexShader);</span><br><span class="line">    glDeleteShader(fragmentShader);</span><br><span class="line">    <span class="comment">// set up vertex data (and buffer(s)) and configure vertex attributes</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// left  </span></span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// right </span></span><br><span class="line">         <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>  <span class="comment">// top   </span></span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO, VAO;</span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="comment">// bind the Vertex Array Object first, then bind and set vertex buffer(s), and then configure vertex attributes(s).</span></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line"></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// note that this is allowed, the call to glVertexAttribPointer registered VBO as the vertex attribute's bound vertex buffer object so afterwards we can safely unbind</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// You can unbind the VAO afterwards so other VAO calls won't accidentally modify this VAO, but this rarely happens. Modifying other</span></span><br><span class="line">    <span class="comment">// VAOs requires a call to glBindVertexArray anyways so we generally don't unbind VAOs (nor VBOs) when it's not directly necessary.</span></span><br><span class="line">    glBindVertexArray(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// uncomment this call to draw in wireframe polygons.</span></span><br><span class="line">    <span class="comment">//glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// render loop</span></span><br><span class="line">    <span class="comment">// -----------</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="comment">// -----</span></span><br><span class="line">        processInput(window);</span><br><span class="line">        <span class="comment">// render</span></span><br><span class="line">        <span class="comment">// ------</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">        <span class="comment">// draw our first triangle</span></span><br><span class="line">        glUseProgram(shaderProgram);</span><br><span class="line">        glBindVertexArray(VAO); <span class="comment">// seeing as we only have a single VAO there's no need to bind it every time, but we'll do so to keep things a bit more organized</span></span><br><span class="line">        glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// glBindVertexArray(0); // no need to unbind it every time </span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span></span><br><span class="line">        <span class="comment">// -------------------------------------------------------------------------------</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// optional: de-allocate all resources once they've outlived their purpose:</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    glDeleteVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glDeleteBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="comment">// glfw: terminate, clearing all previously allocated GLFW resources.</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="EBO"><a href="#EBO" class="headerlink" title="EBO"></a>EBO</h2><p>比如我们要画一个矩形，需要两个三角形，定一堆点，却发现两个点重复的。我们用EBO来处理画点的顺序（这里定四个点的顺序就好0123）。EBO也是个buffer，只不过多存了索引信息。这就是<font color="green">indexed drawing</font>。<br>图005<br><img src="http://i2.bvimg.com/673749/384fa28ecb053c35.png" alt="Markdown"><br>代码流程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ..:: Initialization code :: ..</span></span><br><span class="line"><span class="comment">// 1. bind Vertex Array Object</span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line"><span class="comment">// 2. copy our vertices array in a vertex buffer for OpenGL to use</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 3. copy our index array in a element buffer for OpenGL to use</span></span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 4. then set the vertex attributes pointers</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);  </span><br><span class="line"><span class="comment">// ..:: Drawing code (in render loop) :: ..</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>)</span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>注意：<br>当目标是GL_ELEMENT_ARRAY_BUFFER的时候，VAO存储glBindBuffer调用。<br>这也意味着，在解绑你的VAO之前，不要解绑EBO对象。<br>全部代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span>;</span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *vertexShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line">    <span class="string">"layout (location = 0) in vec3 aPos;\n"</span></span><br><span class="line">    <span class="string">"void main()\n"</span></span><br><span class="line">    <span class="string">"&#123;\n"</span></span><br><span class="line">    <span class="string">"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"</span></span><br><span class="line">    <span class="string">"&#125;\0"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *fragmentShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line">    <span class="string">"out vec4 FragColor;\n"</span></span><br><span class="line">    <span class="string">"void main()\n"</span></span><br><span class="line">    <span class="string">"&#123;\n"</span></span><br><span class="line">    <span class="string">"   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"</span></span><br><span class="line">    <span class="string">"&#125;\n\0"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// glfw: initialize and configure</span></span><br><span class="line">    <span class="comment">// ------------------------------</span></span><br><span class="line">    glfwInit();</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); <span class="comment">// uncomment this statement to fix compilation on OS X</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// glfw window creation</span></span><br><span class="line">    <span class="comment">// --------------------</span></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, <span class="string">"LearnOpenGL"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to create GLFW window"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line">    <span class="comment">// glad: load all OpenGL function pointers</span></span><br><span class="line">    <span class="comment">// ---------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to initialize GLAD"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// build and compile our shader program</span></span><br><span class="line">    <span class="comment">// ------------------------------------</span></span><br><span class="line">    <span class="comment">// vertex shader</span></span><br><span class="line">    <span class="keyword">int</span> vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">    glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(vertexShader);</span><br><span class="line">    <span class="comment">// check for shader compile errors</span></span><br><span class="line">    <span class="keyword">int</span> success;</span><br><span class="line">    <span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fragment shader</span></span><br><span class="line">    <span class="keyword">int</span> fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">    glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(fragmentShader);</span><br><span class="line">    <span class="comment">// check for shader compile errors</span></span><br><span class="line">    glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        glGetShaderInfoLog(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// link shaders</span></span><br><span class="line">    <span class="keyword">int</span> shaderProgram = glCreateProgram();</span><br><span class="line">    glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">    glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">    glLinkProgram(shaderProgram);</span><br><span class="line">    <span class="comment">// check for linking errors</span></span><br><span class="line">    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glDeleteShader(vertexShader);</span><br><span class="line">    glDeleteShader(fragmentShader);</span><br><span class="line">    <span class="comment">// set up vertex data (and buffer(s)) and configure vertex attributes</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// top right</span></span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// bottom right</span></span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// bottom left</span></span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// top left </span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123;  <span class="comment">// note that we start from 0!</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>,  <span class="comment">// first Triangle</span></span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>   <span class="comment">// second Triangle</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO, VAO, EBO;</span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line">    <span class="comment">// bind the Vertex Array Object first, then bind and set vertex buffer(s), and then configure vertex attributes(s).</span></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line"></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">    glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// note that this is allowed, the call to glVertexAttribPointer registered VBO as the vertex attribute's bound vertex buffer object so afterwards we can safely unbind</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>); </span><br><span class="line">    <span class="comment">// remember: do NOT unbind the EBO while a VAO is active as the bound element buffer object IS stored in the VAO; keep the EBO bound.</span></span><br><span class="line">    <span class="comment">//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// You can unbind the VAO afterwards so other VAO calls won't accidentally modify this VAO, but this rarely happens. Modifying other</span></span><br><span class="line">    <span class="comment">// VAOs requires a call to glBindVertexArray anyways so we generally don't unbind VAOs (nor VBOs) when it's not directly necessary.</span></span><br><span class="line">    glBindVertexArray(<span class="number">0</span>); </span><br><span class="line">    <span class="comment">// uncomment this call to draw in wireframe polygons.</span></span><br><span class="line">    <span class="comment">//glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// render loop</span></span><br><span class="line">    <span class="comment">// -----------</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="comment">// -----</span></span><br><span class="line">        processInput(window);</span><br><span class="line">        <span class="comment">// render</span></span><br><span class="line">        <span class="comment">// ------</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">        <span class="comment">// draw our first triangle</span></span><br><span class="line">        glUseProgram(shaderProgram);</span><br><span class="line">        glBindVertexArray(VAO); <span class="comment">// seeing as we only have a single VAO there's no need to bind it every time, but we'll do so to keep things a bit more organized</span></span><br><span class="line">        <span class="comment">//glDrawArrays(GL_TRIANGLES, 0, 6);</span></span><br><span class="line">        glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// glBindVertexArray(0); // no need to unbind it every time </span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span></span><br><span class="line">        <span class="comment">// -------------------------------------------------------------------------------</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// optional: de-allocate all resources once they've outlived their purpose:</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    glDeleteVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glDeleteBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    glDeleteBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line">    <span class="comment">// glfw: terminate, clearing all previously allocated GLFW resources.</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glfw: whenever the window size changed (by OS or user resize) this callback function executes</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// make sure the viewport matches the new window dimensions; note that width and </span></span><br><span class="line">    <span class="comment">// height will be significantly larger than specified on retina displays.</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果见图006<br><img src="http://i2.bvimg.com/673749/41990eb35ecd47dd.png" alt="Markdown"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我这里根据教程将整个过程用自己的语言过额一遍，英语好直接去原post阅读，不好的话也有系列的翻译文章，但是翻译的实在是。。。个人体会，所以自己将整个流程记录了下来。关于shader更详细的文章可以自己再去阅读，比如现在shader都是写在源码里，你可以i定义自己的类去读取shader文本，灵活使用，现在这样硬怼实在是太麻烦了。<br>还有，看来矩阵变换和坐标系要单独写一篇文章了。<br>其实这里还有另外一个想法，写作和学习过程中，一帮国内的博客实在是没眼看，说来说去不是架子太空，专业字眼太多，就是西拼东凑，各有各的逻辑和理解。说实在的，官网的资料一堆既清晰又明白，以后这种学习性质的博客就不会再出了，可能还是更多地分享一些成形的想法、代码和项目。<br>话又说回来，公司的能在这写么。。。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/OpenGL/" rel="tag"># OpenGL</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/05/OpenGL-HelloWorld/" rel="next" title="OpenGL-HelloWorld-Windows">
                <i class="fa fa-chevron-left"></i> OpenGL-HelloWorld-Windows
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/01/11/OpenGL-Transformation-and-Coordinate/" rel="prev" title="OpenGL Transformation and Coordinate">
                OpenGL Transformation and Coordinate <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="KinGil">
          <p class="site-author-name" itemprop="name">KinGil</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/kingiluob" target="_blank" title="Github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      Github
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://weibo.com/2283641104/profile?topnav=1&wvr=6" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      Weibo
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.facebook.com/profile.php?id=100007092155441" target="_blank" title="Facebook">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      Facebook
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#渲染管线"><span class="nav-number">1.</span> <span class="nav-text">渲染管线</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#固定管线和可编程管线"><span class="nav-number">1.1.</span> <span class="nav-text">固定管线和可编程管线</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#状态机"><span class="nav-number">1.2.</span> <span class="nav-text">状态机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象"><span class="nav-number">1.3.</span> <span class="nav-text">对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hellowindow的一些流程解释"><span class="nav-number">1.4.</span> <span class="nav-text">hellowindow的一些流程解释</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#固定管线"><span class="nav-number">1.4.1.</span> <span class="nav-text">固定管线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可编程管线"><span class="nav-number">1.4.2.</span> <span class="nav-text">可编程管线</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#绘制一个三角形"><span class="nav-number">2.</span> <span class="nav-text">绘制一个三角形</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#顶点输入"><span class="nav-number">2.1.</span> <span class="nav-text">顶点输入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vertex-shader"><span class="nav-number">2.2.</span> <span class="nav-text">vertex shader</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编译shader"><span class="nav-number">2.3.</span> <span class="nav-text">编译shader</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#片元shader"><span class="nav-number">2.4.</span> <span class="nav-text">片元shader</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sahder-program"><span class="nav-number">2.5.</span> <span class="nav-text">sahder program</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连接顶点属性"><span class="nav-number">2.6.</span> <span class="nav-text">连接顶点属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vertex-Array-Object"><span class="nav-number">2.7.</span> <span class="nav-text">Vertex Array Object</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#绘制三角形"><span class="nav-number">2.8.</span> <span class="nav-text">绘制三角形</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#完整代码"><span class="nav-number">2.9.</span> <span class="nav-text">完整代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EBO"><span class="nav-number">2.10.</span> <span class="nav-text">EBO</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KinGil</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
